<script src="https://unpkg.com/react@16/umd/react.production.min.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js" crossorigin></script>
<script src="https://unpkg.com/babel-standalone@6/babel.min.js" crossorigin></script>
<script src="https://unpkg.com/axios/dist/axios.min.js" crossorigin></script>

<link href="/front/css/style.css" rel="stylesheet">
<div id="root"></div>
<!--<script src="https://unpkg.com/react@16/umd/react.production.min.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js" crossorigin></script>-->

{literal}

<script type="text/babel" language="javascript">
var KEYCODE_ENTER = 13; 
var KEYCODE_ESC = 27;
var KEYCODE_TAB = 9;

class Tab extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isInEditMode: false,
      tab: props.tabitem,
      tabId: props.tabitem.id,
      addNewTabManage: props.updateTabState,
      insertTabClass: props.insertTabClass,
      projectName: props.tabitem.projectName,
      setEditInsertClick: 'insertTab',
      //cancelInsert:'cancelInsertTab',
      displayBoard: false,
      tabChangeResponse: props.tabChangeResponse,
      
    }

    this.setWrapperRef = this.setWrapperRef.bind(this);
    this.handleClickOutside = this.handleClickOutside.bind(this);
  }  
  
  componentDidMount() {
    if(this.state.tabId=="NEW") {//Adding new project
      this.setState({
        isInEditMode: true
      })
    }
    document.addEventListener('mousedown', this.handleClickOutside);
  }

  componentWillUnmount() {
    document.removeEventListener('mousedown', this.handleClickOutside);
  }

  setWrapperRef(node) {
    this.wrapperRef = node;
  }

  handleClickOutside(event) {
    ////console.log('handleClickOutside');
    if (this.wrapperRef && !this.wrapperRef.contains(event.target)) {  
      if(event.target.classList.contains(this.state.setEditInsertClick)) {
        //alert('clicked insert');
        //this needs to update and display in render with 'add new' active
        //NEW update and display in render with 'add new' active
        //EDIT update display add new active 
        //console.log('insert cliked');
        if(this.state.projectName.length > 0 || this.state.tabId !== 'NEW') { 
          //console.log('update display and active');
          this.updateProjectName();
         // this.state.addNewTabManage(true, [], true);
          //return true;
         // this.changeEditMode();
        } 
        //if editing existing then only update and changeEdit mode to false

      } else { //alert('outside insert');
        //alert('clicked outside');
        this.changeEditMode();

        if(this.state.projectName.length > 0 || this.state.tabId !== 'NEW') { 
          this.updateProjectName();
        } 

        if(this.state.projectName.length === 0 && this.state.tabId === 'NEW') {
          this.state.addNewTabManage(true, []);
        }

      }
      
      //you clicked outside
     /* this.changeEditMode();

      //save also
      if(this.state.projectName.length > 0 || this.state.tabId !== 'NEW') { 
        this.updateProjectName();
      } 
      if(this.state.projectName.length === 0 && this.state.tabId === 'NEW') {
        this.state.addNewTabManage(true, []);
      }*/
      
     /* if(event.target.classList.contains(this.state.setEditInsertClick)) {
       // event.preventDefault();
       //console.log('setEditInsertClick clcieke'); //console.log(this.state.projectName);
        
        if(this.state.projectName.length !== 0 && this.state.tabId === 'NEW') {
            //this needs to update and display in render with add new active
            //alert(this.state.projectName.length); alert(this.state.projectName);
           // this.updateProjectName();
           //this.state.addNewTabManage(true, [], true);
           return true;
        }

        //this.state.addNewTabManage(true, [], true);
       // return true;
      }*/

    }
  }

  updateProjectName =()=>{
    ////console.log('project will update here');
    ////console.log(this.state.tab); 
    const newTabValue  = {
      id: this.state.tab.id,
      projectName: this.state.projectName,
      userId: this.state.tab.userId
    };
    var url = '/taskmanagement/updateProject/';
    const encodeForm = (newTabValue) => {
      return Object.keys(newTabValue)
          .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(newTabValue[key]))
          .join('&');
    }
    var self = this;
    var addTabState = true;
    if(this.state.tab.id !== 'NEW' && !event.target.classList.contains(this.state.insertTabClass)) addTabState = false;
    var newChildren ='';
    var insertTabClassException = false;
    if(event.target.classList.contains(this.state.insertTabClass)) {
      //console.log('insertclas clicked we know that');
      insertTabClassException=true;
    }
    /*if(newTabValue.id !== 'NEW') {
     newChildren ='';
    }*/
   // //console.log(newTabValue.id );
    axios.post(url, encodeForm(newTabValue), {headers: {'Accept': 'application/json'}})
        .then(function (response) {
            if(addTabState === true) newChildren = response.data;

            //communicating with Parent Tabpanel 
            //console.log('in update');
            //console.log(addTabState);
            //console.log(newChildren);
            //insertTabClassException
            self.state.addNewTabManage(addTabState, newChildren, false, insertTabClassException);

          //TODO-if project deleted then
          console.log('project updateed');
          console.log(response.data);

          if(response.data !== 'deleted') {
            //setState itemId for new record
            self.setState({ tab: response.data})
          }
            
        })
        .catch(function (error) {
            //Display task item update failed!
    });
  }

  changeEditMode =()=>{
    this.setState({
      isInEditMode: !this.state.isInEditMode
    })
  }

  handleChange = (e) => { 
    this.setState({ projectName: e.target.value });
  }

  handleKeyDown = (e) => {

    if (e.keyCode === KEYCODE_ENTER || e.keyCode === KEYCODE_TAB) {
      this.changeEditMode();
      //save also
      if(this.state.projectName.length > 0 || this.state.tabId !== 'NEW') {
        this.updateProjectName();
      }
    }
    if(e.keyCode === KEYCODE_ESC) {
      //Do not save and close new input
      this.setState({ isInEditMode: !this.state.isInEditMode })
      if(this.state.tabId=="NEW") {
        this.setState({projectName: ''})
      } else {
        this.setState({projectName: this.state.tab.projectName})
      }
      this.state.addNewTabManage(true, []);
    }
  }

  renderEditView =()=>{
    return (
      <div>
        <input 
        className="projectTab"
        type="text"
        //autofocus={this.state.autofocus}
        defaultValue={this.state.projectName}
        ref={this.setWrapperRef}
        //ref={this.childRef}
        onChange={this.handleChange}
        onKeyDown={this.handleKeyDown}
      />
      </div>
      )
  }
  renderTextView =()=>{
    return (
      <div 
          onClick={this.displayBoard}
          onDoubleClick={this.changeEditMode} 
          className="projectTab"
        >
        {this.state.projectName}
      </div>
      )
  }

  displayBoard=()=>{ ////console.log(this.state.tabId);
    this.state.tabChangeResponse(this.state.tabId);
    //this.setState({ displayBoard: true })
    // TODO- onclick should display active projectTab
    //display only board with className eqauls to tabId
  }

  render() {
    return (
      this.state.isInEditMode  ?
      this.renderEditView() :
      this.renderTextView()
      
     // this.state.displayBoard !== false) ? <Board items={this.state.allTaskItems} userId={this.state.userId}/>
    )
  }

}

class Tabpanel extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      addTab:true,
      userId:props.userId,
      insertItemClass:'insertTab',
      tabitems: props.tabitems,
      displayBoard: props.displayBoard,
    //  tablist:['tab1', 'tab2', 'tab3'],
    }
  }

  tabChangeResponse=(projectId)=>{
    this.state.displayBoard(projectId);
    //console.log('child called me');
  }

  addNewTab=(childAddNewItemState, childItem, editAndInsertClick = false, insertTabClassException=false)=>{
    //console.log('add new item');
    //console.log('addTab state in before is');
    //console.log(this.state.addTab);
    //Get last item in taskitems

    if(insertTabClassException === true) {
    //  console.log('insertTabClassException');
    //  console.log(this.state.tabitems);
    //  console.log(childItem);
      var tabTemp = this.state.tabitems.filter(function(obj) {
          return obj.id !== 'NEW';
      });
      //add child item in task state
      if(Object.entries(childItem).length !== 0) {
        tabTemp =  [...tabTemp, childItem];
      }
      this.setState({ tabitems: tabTemp} )
    } else {
      //temp

      var { [Object.keys(this.state.tabitems).pop()]: lastItem } = this.state.tabitems;
      if(this.state.addTab === true && childAddNewItemState === true) { //ready to add 'NEW' blank item
      //  console.log('adding NEW in IF');
        if(Object.entries(this.state.tabitems).length === 0 || lastItem.id !== 'NEW') { 
          const newTab = {id:'NEW', projectName:'', userId: this.state.userId}
          this.setState(
            { tabitems: [...this.state.tabitems, newTab]}
          )
        }
      } else { //remove NEW item
      //  console.log('removing NEW in ELSE');
        var tabTemp = this.state.tabitems.filter(function(obj) {
            return obj.id !== 'NEW';
        });
        //add child item in task state
        if(Object.entries(childItem).length !== 0) {
          tabTemp =  [...tabTemp, childItem];
        }
        this.setState({ tabitems: tabTemp} )
      // console.log(this.state.tabitems);
      }

      //change state addItem
      if(childAddNewItemState === true && editAndInsertClick === false) { 
        //console.log('changing addTab state in OUTSIDE to ');
        this.setState({ addTab: !this.state.addTab })
      // console.log('to');
      // console.log(this.state.addTab);
      }
    }
  }

  render() {
    var addNewTabFunction = this.addNewTab;
    var tabChangeResFunction = this.tabChangeResponse;
   // var addTabTextToggle = (this.state.addTab === true) ? 'Add new' : '';
   // var insertTabClassToggle = (this.state.addTab === true) ? 'insertTab' : 'cancelInsertTab';
   var insertTabClassToggle = 'insertTab';
    return (
      <div className="tabs">
        {this.state.tabitems.map(function(item, index){
          return <Tab 
                      key={index} 
                      tabitem={item}
                      updateTabState={addNewTabFunction} 
                      tabChangeResponse={tabChangeResFunction}
                      insertTabClass={insertTabClassToggle}
                  />
        })}
        {/*<div className={insertTabClassToggle} onClick={() => this.addNewTab(true, []) }>{addTabTextToggle}</div>*/}
        <div className={insertTabClassToggle} onClick={() => this.addNewTab(true, []) }>Add new</div>
      </div>
    )
  }

}


class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      userId: 1,
      allTabItems: [],
      allTaskItems: [],
      //projectTaskItems: null,
      projectId: 0,
    }
  }


  /*componentWillMount : function () {
    var data = this.getData();
    this.setState({data : data});
  }*/

  async componentDidMount() {
      const id = this.state.userId // we grab the ID from the URL
      await axios.get(`/taskmanagement/projecttasks/${id}`)
                  .then(response => {

                  const projectsInfo = Array.from(new Set(response.data.map(p=>p.projectId)))
                  .map(id=> {
                    return {
                      id: id,
                      projectName: response.data.find(p => p.projectId == id).projectName,
                      userId: response.data.find(p => p.projectId == id).userId,
                    }
                  })
                  this.setState({
                    allTabItems: projectsInfo, 
                    allTaskItems: response.data,
                    projectId: projectsInfo[0].id
                  })
                  //console.log(response.data);

        }).catch(err => console.log(err))

        //TODO- if no tab then set default tab

    }


  displayBoard=(clickedprojectId)=>{
    //this function is responsible for displaying particular project
    console.log('i got clickedprojectId from Tab component child of child');
    this.setState({projectId: clickedprojectId})
    
  }

  render() {
  //  console.log('Ap render');
  //  console.log(this.state.projectId);
    return ( 
      <div className="app">
        {Object.entries(this.state.allTabItems).length !== 0  && 
          <div className="tabpanelContainer">
            <Tabpanel 
              tabitems={this.state.allTabItems} 
              userId={this.state.userId} 
              displayBoard={this.displayBoard} 
            />
          </div>
          }
          <br />
          {this.state.projectId !== 0 && 
            <Projects
              allProjects={this.state.allTabItems}
              allProjectsTasks={this.state.allTaskItems}  
              projectId={this.state.projectId} 
              userId={this.state.userId}
            />
          }
          {/*{this.state.allTabItems !== null && <Board items={this.state.projectTaskItems} userId={this.state.userId}/>}*/}
      </div>
    );
  }
}

class Projects2 extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      userId: props.userId,
      projectTaskItems: props.allProjectsTasks,
      projectId: props.projectId,
      allProjects: props.allProjects
    }
    console.log('project const ProjectsId'); console.log(this.state.projectId);
  }

  /*componentWillReceiveProps({projectId}) {
    this.setState({...this.state,projectId})
  }*/
  componentWillReceiveProps(nextProps) {
    this.setState({ projectId: nextProps.projectId });  
  }

  render() {
    console.log('Projects2 render ProjectsId'); console.log(this.state.projectId);
    return (
      <h1></h1>
    )
  }
}

class Projects extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      userId: props.userId,
      projectTaskItems: props.allProjectsTasks,
      projectId: props.projectId,
      allProjects: props.allProjects
    }
    //console.log('project1 const ProjectsId'); console.log(this.state.projectId);
  }

  componentWillReceiveProps(nextProps) {
    this.setState({ projectId: nextProps.projectId });  
  }
  render() {
    //get all projects create div for them also. But only show div which className/id matches with projectId
 //   console.log('Projects projectTaskItems=>');
//    console.log(this.state.allProjects)
 //   console.log(this.state.projectTaskItems);
      var userId = this.state.userId;
      var activeProjectId = this.state.projectId;
      var projectTaskItems = this.state.projectTaskItems;
      console.log('Projects1 render ProjectsId'); console.log(this.state.projectId);
    return (
      <div className="projectsContainer">
          Board will display here
          {/*TODO - no need to go through all project check for projectId in map*/}
          {this.state.allProjects.map(function(item, index) {
          // console.log('project1 allProjects=>'); console.log(item);
            var allProjectsItem = item;
            const taskitems = [];
            projectTaskItems.map(function(item, index) {
                if(item.projectId  === allProjectsItem.id && item.id.length > 0) {
                  taskitems.push(item);
                }
            });
            //separate taskitem per project
           // projectTaskItems.map
          // console.log('taskitems=>');
          // console.log(taskitems);
          return (
            
              <Board 
                  key={index} 
                  userId={userId} 
                  items={taskitems} 
                  projectId={activeProjectId}
                  boardProjectId={item.id}
                />
            
          )
                 
        })}
      </div>

    )
  }
}
class Board extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      userId:props.userId,
      taskitem:props.items,
      activeProjectId: props.projectId,
      boardProjectId: props.boardProjectId
		}
  //  console.log('board in const');
   // console.log(this.state.taskitem);
  }
  componentWillReceiveProps(nextProps) { //without this Board will not render on parent Project's state:projectId
    this.setState({ activeProjectId: nextProps.projectId });  
  }

  render() {
    console.log('board get called');
    //Separating taskitems in quadrant from their urgent and important value
    //adding element 'type' for css issue
    const ui = []; const un = [];
    const ni = []; const nn = [];

    var boardProjectId = this.state.boardProjectId;

    /*if(Object.entries(this.state.taskitem).length !== 0) {
      boardProjectId = this.state.taskitem[0].projectId;
    } else {
      //boardProjectId = this.state.activeProjectId;
    }*/
    this.state.taskitem.forEach((item, index) => {
      if(item.urgent==1 && item.important==1) { 
            item.type = 'ui'; ui.push(item);
      }
      if(item.urgent==1 && item.important==0) {
          item.type = 'un'; un.push(item);
      }
      if(item.urgent==0 && item.important==1) {
          item.type = 'ni'; ni.push(item);
      }
      if(item.urgent==0 && item.important==0) {
          item.type = 'nn'; nn.push(item);
      }
    });
    console.log('Board taskitems=>'); 
    //console.log(this.state.taskitem);
    console.log('Board clciked projectId');
    console.log(this.state.activeProjectId);
    console.log('Board this board projectid');
    console.log(boardProjectId);
    return (
      <div className="Board">
        {
          this.state.boardProjectId == this.state.activeProjectId && 
          <div className={this.state.activeProjectId}>
          <div className="parent">
            <div className="div1"> </div>
            <div className="div2"> <p>Important</p></div>
            <div className="div3"> <p>Not Important</p></div>
            <div className="div4"> <p className="verticaltext">Urgent</p></div>
            <div className="div5"> <Quadrant type="ui" quadrantTasks={ui} projectId={this.state.boardProjectId} /></div>
            <div className="div6"> <Quadrant type="un" quadrantTasks={un} projectId={this.state.boardProjectId} /></div>
            <div className="div7"> <p className="verticaltext">Not Urgent</p></div>
            <div className="div8"> <Quadrant type="ni" quadrantTasks={ni} projectId={this.state.boardProjectId} /></div>
            <div className="div9"> <Quadrant type="nn" quadrantTasks={nn} projectId={this.state.boardProjectId} /></div>
          </div>
          </div>
      }
    </div>
    );
  }  

}

/*
* Quadrant as per Urgent and Important divison
*/
class Quadrant extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      addItem: true,
      type: props.type,
      //userId:props.userId,
      projectId: props.projectId,
      tasks: props.quadrantTasks,
      insertItemClass: 'insertItem'
    }
  }


  addNewItem=(childAddNewItemState, childItem, editAndInsertClick = false) => {
    //Get last item in taskitems
    var { [Object.keys(this.state.tasks).pop()]: lastItem } = this.state.tasks;
    if(this.state.addItem === true && childAddNewItemState === true){//ready to add 'NEW' blank item
      if(Object.entries(this.state.tasks).length === 0 || lastItem.id !== 'NEW') { 
        var urgent = 1; var important = 1;
        if(this.state.type =='ui') {  urgent=1;  important = 1;}
        if(this.state.type =='un') {  urgent=1;  important = 0;}
        if(this.state.type =='ni') {  urgent=0;  important = 1;}
        if(this.state.type =='nn') {  urgent=0;  important = 0;}
        const newItem = {id: 'NEW', task: '', projectId: this.state.projectId, urgent:urgent, important:important, type:this.state.type, autofocus:'autofocus'};
        this.setState(
          { tasks: [...this.state.tasks, newItem]}
        )
      }
    } else { //remove NEW item
      var taskTemp = this.state.tasks.filter(function(obj) {
          return obj.id !== 'NEW';
      });
      //add child item in task state
      if(Object.entries(childItem).length !== 0) {
        taskTemp =  [...taskTemp, childItem];
      }
      this.setState({ tasks: taskTemp} )
    }

    //change state addItem
    if(childAddNewItemState === true && editAndInsertClick === false) { 
      this.setState({ addItem: !this.state.addItem })
    }
  }


  render() {
    var addNewItemFunction = this.addNewItem;
    var addTaskTextToggle = (this.state.addItem === true) ? 'Add new task item here' : 'Cancel adding task';
    var insertItemClassToggle = (this.state.addItem === true) ? 'insertItem-'+this.state.type : 'cancelInsert';
    
    return (
      <div>
        {this.state.tasks.map(function(item, index){
          return <Item 
                      key={index} 
                      taskitem={item} 
                      updateItemState={addNewItemFunction} 
                      insertItemClass={insertItemClassToggle}
                  />
        })}
        <div className={insertItemClassToggle} onClick={() => this.addNewItem(true, []) }>{addTaskTextToggle}</div>
      </div>
    )
  }

}

/*
* Individual Task Item Box
* Either task text or Editable task item
*/
class Item extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isInEditMode: false,
      item: props.taskitem,
      itemId: props.taskitem.id,
      task: props.taskitem.task,
      className: props.taskitem.type,
      addNewManage: props.updateItemState,
      insertItemClass: props.insertItemClass,
      setEditInsertClick: 'insertItem-'+ props.taskitem.type,
      cancelInsert:'cancelInsert',
      //autofocus: props.taskitem.autofocus,
      autofocus: ''
    }

    this.setWrapperRef = this.setWrapperRef.bind(this);
    this.handleClickOutside = this.handleClickOutside.bind(this);
  }

  componentDidUpdate(prevProps, prevState) {
    //this._input.focus();
   // console.log('prevprops'); console.log(prevProps);
  //  console.log('prevstate'); console.log(prevState);
    //this._input.focus();
   // console.log('componentDidUpdate');
    //this.wrapperRef.focus();
   // console.log(this.wrapperRef);
    // x = document.getElementById("ui");
    //document.getElementById("ui").focus();
    //console.log(x);
    //this.input.current.focus();
    //this.setState({ autofocus: 'autofocus' });
  }

  componentDidMount() {
    if(this.state.itemId=="NEW") {//Adding new task
      this.setState({
        isInEditMode: true
      })
     // console.log(this.state.className);
    //  var newInput = document.getElementsByClassName("ui").item(0);
    //  console.log(newInput);
      //newInput.focus(); 
    }
    document.addEventListener('mousedown', this.handleClickOutside);
  }

  componentWillUnmount() {
    document.removeEventListener('mousedown', this.handleClickOutside);
  }
  
  handleClickOutside(event) { /*
    if (this.wrapperRef && !this.wrapperRef.contains(event.target) && !event.target.classList.contains(this.state.cancelInsert)) {  
      
      this.setState({ autofocus: '' });
      //you clicked outside
      this.changeEditMode();
      //save also
      if(this.state.task.length > 0 || this.state.itemId !== 'NEW') {
        this.updateItemValue();
      } 
      if(this.state.task.length === 0 && this.state.itemId === 'NEW') {
        this.state.addNewManage(true, []);
      }
      if(event.target.classList.contains(this.state.setEditInsertClick)) {
        this.state.addNewManage(true, [], true);
      }
    }*/
  }
  
  setWrapperRef(node) {
    this.wrapperRef = node;
  }

  updateItemValue =()=>{
    //Update in DB and render in item
    const newItemValue  = {
      id: this.state.item.id,
      task: this.state.task,
      projectId: this.state.item.projectId,
      urgent: this.state.item.urgent,
      important:this.state.item.important
    };
    
    var url = '/taskmanagement/updatetask/';
    const encodeForm = (newItemValue) => {
      return Object.keys(newItemValue)
          .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(newItemValue[key]))
          .join('&');
    }
    var self = this;
    var additemsState = true;
    if(this.state.item.id !== 'NEW' && !event.target.classList.contains(this.state.insertItemClass)) additemsState = false;
    var newChildren ='';
    axios.post(url, encodeForm(newItemValue), {headers: {'Accept': 'application/json'}})
        .then(function (response) {
            if(additemsState === true) newChildren = response.data;

            //communicating with Quadrant
            self.state.addNewManage(additemsState, newChildren);

            //setState itemId for new record
            self.setState({
              item: response.data,
              autofocus:''
            })
        })
        .catch(function (error) {
            //Display task item update failed!
    });
  }

  changeEditMode =()=>{
    
    this.setState({
      isInEditMode: !this.state.isInEditMode
    })
  }
  handleChange = (e) => { 
    this.setState({ task: e.target.value });
  }
  handleKeyDown = (e) => {

    if (e.keyCode === KEYCODE_ENTER || e.keyCode === KEYCODE_TAB) {
      this.changeEditMode();
      //save also
      if(this.state.task.length > 0 || this.state.itemId !== 'NEW') {
        this.updateItemValue();
      }
    }
    if(e.keyCode === KEYCODE_ESC) {
      //Do not save and close new input
      this.setState({ isInEditMode: !this.state.isInEditMode })
      if(this.state.itemId=="NEW") {
        this.setState({task: '', autofocus:''})
      } else {
        this.setState({task: this.state.item.task})
      }
      this.state.addNewManage(true, []);
    }
  }

  renderEditView =()=>{
    console.log('className='); console.log(this.state.className);
    console.log('taskvalue='); console.log(this.state.task);
    console.log('autfocus='); console.log(this.state.autofocus);
    return (
      <div>
        <input 
        id={this.state.className}
        className={this.state.className}
        type="text"
        //autofocus={this.state.autofocus}
        defaultValue={this.state.task}
        //ref={this.setWrapperRef}
        ref={this.childRef}
        onChange={this.handleChange}
        onKeyDown={this.handleKeyDown}
      />
      </div>
      )
  }

  renderTextView =()=>{
    return (
      <div onDoubleClick={this.changeEditMode}>
        {this.state.task}
      </div>
      )
  }


  render() {
    return (
      this.state.isInEditMode  ?
      this.renderEditView() :
      this.renderTextView()
    )
  }

}

ReactDOM.render(
  <App />,
  document.getElementById('root')
);
</script>
{/literal}